// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: common.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _common_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Decimal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Decimal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Decimal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DecimalMultiError, or nil if none found.
func (m *Decimal) ValidateAll() error {
	return m.validate(true)
}

func (m *Decimal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetValue()) < 1 {
		err := DecimalValidationError{
			field:  "Value",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DecimalMultiError(errors)
	}

	return nil
}

// DecimalMultiError is an error wrapping multiple validation errors returned
// by Decimal.ValidateAll() if the designated constraints aren't met.
type DecimalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DecimalMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DecimalMultiError) AllErrors() []error { return m }

// DecimalValidationError is the validation error returned by Decimal.Validate
// if the designated constraints aren't met.
type DecimalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DecimalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DecimalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DecimalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DecimalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DecimalValidationError) ErrorName() string { return "DecimalValidationError" }

// Error satisfies the builtin error interface
func (e DecimalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDecimal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DecimalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DecimalValidationError{}

// Validate checks the field values on Uuid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Uuid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uuid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UuidMultiError, or nil if none found.
func (m *Uuid) ValidateAll() error {
	return m.validate(true)
}

func (m *Uuid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetValue()); err != nil {
		err = UuidValidationError{
			field:  "Value",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UuidMultiError(errors)
	}

	return nil
}

func (m *Uuid) _validateUuid(uuid string) error {
	if matched := _common_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UuidMultiError is an error wrapping multiple validation errors returned by
// Uuid.ValidateAll() if the designated constraints aren't met.
type UuidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UuidMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UuidMultiError) AllErrors() []error { return m }

// UuidValidationError is the validation error returned by Uuid.Validate if the
// designated constraints aren't met.
type UuidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UuidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UuidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UuidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UuidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UuidValidationError) ErrorName() string { return "UuidValidationError" }

// Error satisfies the builtin error interface
func (e UuidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUuid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UuidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UuidValidationError{}

// Validate checks the field values on DateTime with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DateTime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DateTime with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DateTimeMultiError, or nil
// if none found.
func (m *DateTime) ValidateAll() error {
	return m.validate(true)
}

func (m *DateTime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DateTimeValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DateTimeValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DateTimeValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DateTimeMultiError(errors)
	}

	return nil
}

// DateTimeMultiError is an error wrapping multiple validation errors returned
// by DateTime.ValidateAll() if the designated constraints aren't met.
type DateTimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DateTimeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DateTimeMultiError) AllErrors() []error { return m }

// DateTimeValidationError is the validation error returned by
// DateTime.Validate if the designated constraints aren't met.
type DateTimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DateTimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DateTimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DateTimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DateTimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DateTimeValidationError) ErrorName() string { return "DateTimeValidationError" }

// Error satisfies the builtin error interface
func (e DateTimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDateTime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DateTimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DateTimeValidationError{}

// Validate checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Value) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ValueMultiError, or nil if none found.
func (m *Value) ValidateAll() error {
	return m.validate(true)
}

func (m *Value) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	switch v := m.Type.(type) {
	case *Value_Null:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Null
	case *Value_Int32:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Int32
	case *Value_Uint32:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Uint32
	case *Value_Int64:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Int64
	case *Value_Uint64:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Uint64
	case *Value_Float:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Float
	case *Value_Double:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Double
	case *Value_String_:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for String_
	case *Value_Bool:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Bool
	case *Value_Decimal:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDecimal()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Decimal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Decimal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDecimal()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "Decimal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_Uuid:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUuid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Uuid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Uuid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUuid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "Uuid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_Datetime:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatetime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Datetime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Datetime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatetime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "Datetime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_Struct_:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStruct()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Struct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "Struct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStruct()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "Struct",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_List_:
		if v == nil {
			err := ValueValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "List",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "List",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "List",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ValueMultiError(errors)
	}

	return nil
}

// ValueMultiError is an error wrapping multiple validation errors returned by
// Value.ValidateAll() if the designated constraints aren't met.
type ValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMultiError) AllErrors() []error { return m }

// ValueValidationError is the validation error returned by Value.Validate if
// the designated constraints aren't met.
type ValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueValidationError) ErrorName() string { return "ValueValidationError" }

// Error satisfies the builtin error interface
func (e ValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueValidationError{}

// Validate checks the field values on Generation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Generation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GenerationMultiError, or
// nil if none found.
func (m *Generation) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GenerationMultiError(errors)
	}

	return nil
}

// GenerationMultiError is an error wrapping multiple validation errors
// returned by Generation.ValidateAll() if the designated constraints aren't met.
type GenerationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerationMultiError) AllErrors() []error { return m }

// GenerationValidationError is the validation error returned by
// Generation.Validate if the designated constraints aren't met.
type GenerationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerationValidationError) ErrorName() string { return "GenerationValidationError" }

// Error satisfies the builtin error interface
func (e GenerationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerationValidationError{}

// Validate checks the field values on Value_List with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Value_List) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Value_List with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Value_ListMultiError, or
// nil if none found.
func (m *Value_List) ValidateAll() error {
	return m.validate(true)
}

func (m *Value_List) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Value_ListValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Value_ListValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Value_ListValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Value_ListMultiError(errors)
	}

	return nil
}

// Value_ListMultiError is an error wrapping multiple validation errors
// returned by Value_List.ValidateAll() if the designated constraints aren't met.
type Value_ListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Value_ListMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Value_ListMultiError) AllErrors() []error { return m }

// Value_ListValidationError is the validation error returned by
// Value_List.Validate if the designated constraints aren't met.
type Value_ListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Value_ListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Value_ListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Value_ListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Value_ListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Value_ListValidationError) ErrorName() string { return "Value_ListValidationError" }

// Error satisfies the builtin error interface
func (e Value_ListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValue_List.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Value_ListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Value_ListValidationError{}

// Validate checks the field values on Value_Struct with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Value_Struct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Value_Struct with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Value_StructMultiError, or
// nil if none found.
func (m *Value_Struct) ValidateAll() error {
	return m.validate(true)
}

func (m *Value_Struct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Value_StructValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Value_StructValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Value_StructValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Value_StructMultiError(errors)
	}

	return nil
}

// Value_StructMultiError is an error wrapping multiple validation errors
// returned by Value_Struct.ValidateAll() if the designated constraints aren't met.
type Value_StructMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Value_StructMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Value_StructMultiError) AllErrors() []error { return m }

// Value_StructValidationError is the validation error returned by
// Value_Struct.Validate if the designated constraints aren't met.
type Value_StructValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Value_StructValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Value_StructValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Value_StructValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Value_StructValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Value_StructValidationError) ErrorName() string { return "Value_StructValidationError" }

// Error satisfies the builtin error interface
func (e Value_StructValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValue_Struct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Value_StructValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Value_StructValidationError{}

// Validate checks the field values on Generation_Alphabet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Alphabet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Alphabet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_AlphabetMultiError, or nil if none found.
func (m *Generation_Alphabet) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Alphabet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRanges()) < 1 {
		err := Generation_AlphabetValidationError{
			field:  "Ranges",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRanges() {
		_, _ = idx, item

		if item == nil {
			err := Generation_AlphabetValidationError{
				field:  fmt.Sprintf("Ranges[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_AlphabetValidationError{
						field:  fmt.Sprintf("Ranges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_AlphabetValidationError{
						field:  fmt.Sprintf("Ranges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_AlphabetValidationError{
					field:  fmt.Sprintf("Ranges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Generation_AlphabetMultiError(errors)
	}

	return nil
}

// Generation_AlphabetMultiError is an error wrapping multiple validation
// errors returned by Generation_Alphabet.ValidateAll() if the designated
// constraints aren't met.
type Generation_AlphabetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_AlphabetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_AlphabetMultiError) AllErrors() []error { return m }

// Generation_AlphabetValidationError is the validation error returned by
// Generation_Alphabet.Validate if the designated constraints aren't met.
type Generation_AlphabetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_AlphabetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_AlphabetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_AlphabetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_AlphabetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_AlphabetValidationError) ErrorName() string {
	return "Generation_AlphabetValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_AlphabetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Alphabet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_AlphabetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_AlphabetValidationError{}

// Validate checks the field values on Generation_Distribution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Distribution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Distribution with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_DistributionMultiError, or nil if none found.
func (m *Generation_Distribution) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Distribution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := Generation_Distribution_DistributionType_name[int32(m.GetType())]; !ok {
		err := Generation_DistributionValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetScrew() < 0 {
		err := Generation_DistributionValidationError{
			field:  "Screw",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Generation_DistributionMultiError(errors)
	}

	return nil
}

// Generation_DistributionMultiError is an error wrapping multiple validation
// errors returned by Generation_Distribution.ValidateAll() if the designated
// constraints aren't met.
type Generation_DistributionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_DistributionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_DistributionMultiError) AllErrors() []error { return m }

// Generation_DistributionValidationError is the validation error returned by
// Generation_Distribution.Validate if the designated constraints aren't met.
type Generation_DistributionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_DistributionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_DistributionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_DistributionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_DistributionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_DistributionValidationError) ErrorName() string {
	return "Generation_DistributionValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_DistributionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Distribution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_DistributionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_DistributionValidationError{}

// Validate checks the field values on Generation_Range with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_RangeMultiError, or nil if none found.
func (m *Generation_Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Generation_RangeMultiError(errors)
	}

	return nil
}

// Generation_RangeMultiError is an error wrapping multiple validation errors
// returned by Generation_Range.ValidateAll() if the designated constraints
// aren't met.
type Generation_RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_RangeMultiError) AllErrors() []error { return m }

// Generation_RangeValidationError is the validation error returned by
// Generation_Range.Validate if the designated constraints aren't met.
type Generation_RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_RangeValidationError) ErrorName() string { return "Generation_RangeValidationError" }

// Error satisfies the builtin error interface
func (e Generation_RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_RangeValidationError{}

// Validate checks the field values on Generation_Rules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_RulesMultiError, or nil if none found.
func (m *Generation_Rules) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Generation_RulesMultiError(errors)
	}

	return nil
}

// Generation_RulesMultiError is an error wrapping multiple validation errors
// returned by Generation_Rules.ValidateAll() if the designated constraints
// aren't met.
type Generation_RulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_RulesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_RulesMultiError) AllErrors() []error { return m }

// Generation_RulesValidationError is the validation error returned by
// Generation_Rules.Validate if the designated constraints aren't met.
type Generation_RulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_RulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_RulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_RulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_RulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_RulesValidationError) ErrorName() string { return "Generation_RulesValidationError" }

// Error satisfies the builtin error interface
func (e Generation_RulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_RulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_RulesValidationError{}

// Validate checks the field values on Generation_Rule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_RuleMultiError, or nil if none found.
func (m *Generation_Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *Generation_Rule_FloatRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetFloatRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "FloatRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "FloatRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFloatRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "FloatRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_DoubleRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDoubleRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DoubleRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DoubleRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDoubleRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "DoubleRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_Int32Rules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetInt32Rules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Int32Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Int32Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInt32Rules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "Int32Rules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_Int64Rules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetInt64Rules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Int64Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Int64Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInt64Rules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "Int64Rules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_Uint32Rules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetUint32Rules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Uint32Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Uint32Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUint32Rules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "Uint32Rules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_Uint64Rules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetUint64Rules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Uint64Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Uint64Rules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUint64Rules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "Uint64Rules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_BoolRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetBoolRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "BoolRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "BoolRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBoolRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "BoolRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_StringRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetStringRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "StringRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "StringRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStringRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "StringRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_DatetimeRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDatetimeRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DatetimeRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DatetimeRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatetimeRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "DatetimeRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_UuidRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetUuidRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "UuidRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "UuidRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUuidRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "UuidRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Rule_DecimalRules:
		if v == nil {
			err := Generation_RuleValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDecimalRules()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DecimalRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "DecimalRules",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDecimalRules()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "DecimalRules",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := Generation_RuleValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Distribution != nil {

		if all {
			switch v := interface{}(m.GetDistribution()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Distribution",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_RuleValidationError{
						field:  "Distribution",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistribution()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_RuleValidationError{
					field:  "Distribution",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NullPercentage != nil {

		if m.GetNullPercentage() <= 0 {
			err := Generation_RuleValidationError{
				field:  "NullPercentage",
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Unique != nil {
		// no validation rules for Unique
	}

	if len(errors) > 0 {
		return Generation_RuleMultiError(errors)
	}

	return nil
}

// Generation_RuleMultiError is an error wrapping multiple validation errors
// returned by Generation_Rule.ValidateAll() if the designated constraints
// aren't met.
type Generation_RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_RuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_RuleMultiError) AllErrors() []error { return m }

// Generation_RuleValidationError is the validation error returned by
// Generation_Rule.Validate if the designated constraints aren't met.
type Generation_RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_RuleValidationError) ErrorName() string { return "Generation_RuleValidationError" }

// Error satisfies the builtin error interface
func (e Generation_RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_RuleValidationError{}

// Validate checks the field values on Generation_Range_AnyStringRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_AnyStringRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_AnyStringRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Generation_Range_AnyStringRangeMultiError, or nil if none found.
func (m *Generation_Range_AnyStringRange) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_AnyStringRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_AnyStringRangeMultiError(errors)
	}

	return nil
}

// Generation_Range_AnyStringRangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_AnyStringRange.ValidateAll()
// if the designated constraints aren't met.
type Generation_Range_AnyStringRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_AnyStringRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_AnyStringRangeMultiError) AllErrors() []error { return m }

// Generation_Range_AnyStringRangeValidationError is the validation error
// returned by Generation_Range_AnyStringRange.Validate if the designated
// constraints aren't met.
type Generation_Range_AnyStringRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_AnyStringRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_AnyStringRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_AnyStringRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_AnyStringRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_AnyStringRangeValidationError) ErrorName() string {
	return "Generation_Range_AnyStringRangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_AnyStringRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_AnyStringRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_AnyStringRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_AnyStringRangeValidationError{}

// Validate checks the field values on Generation_Range_FloatRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_FloatRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_FloatRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_FloatRangeMultiError, or nil if none found.
func (m *Generation_Range_FloatRange) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_FloatRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_FloatRangeMultiError(errors)
	}

	return nil
}

// Generation_Range_FloatRangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_FloatRange.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_FloatRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_FloatRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_FloatRangeMultiError) AllErrors() []error { return m }

// Generation_Range_FloatRangeValidationError is the validation error returned
// by Generation_Range_FloatRange.Validate if the designated constraints
// aren't met.
type Generation_Range_FloatRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_FloatRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_FloatRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_FloatRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_FloatRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_FloatRangeValidationError) ErrorName() string {
	return "Generation_Range_FloatRangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_FloatRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_FloatRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_FloatRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_FloatRangeValidationError{}

// Validate checks the field values on Generation_Range_DoubleRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_DoubleRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_DoubleRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_DoubleRangeMultiError, or nil if none found.
func (m *Generation_Range_DoubleRange) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DoubleRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_DoubleRangeMultiError(errors)
	}

	return nil
}

// Generation_Range_DoubleRangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_DoubleRange.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_DoubleRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DoubleRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DoubleRangeMultiError) AllErrors() []error { return m }

// Generation_Range_DoubleRangeValidationError is the validation error returned
// by Generation_Range_DoubleRange.Validate if the designated constraints
// aren't met.
type Generation_Range_DoubleRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DoubleRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DoubleRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DoubleRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DoubleRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DoubleRangeValidationError) ErrorName() string {
	return "Generation_Range_DoubleRangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DoubleRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DoubleRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DoubleRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DoubleRangeValidationError{}

// Validate checks the field values on Generation_Range_Int32Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_Int32Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_Int32Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_Int32RangeMultiError, or nil if none found.
func (m *Generation_Range_Int32Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_Int32Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_Int32RangeMultiError(errors)
	}

	return nil
}

// Generation_Range_Int32RangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_Int32Range.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_Int32RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_Int32RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_Int32RangeMultiError) AllErrors() []error { return m }

// Generation_Range_Int32RangeValidationError is the validation error returned
// by Generation_Range_Int32Range.Validate if the designated constraints
// aren't met.
type Generation_Range_Int32RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_Int32RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_Int32RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_Int32RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_Int32RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_Int32RangeValidationError) ErrorName() string {
	return "Generation_Range_Int32RangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_Int32RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_Int32Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_Int32RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_Int32RangeValidationError{}

// Validate checks the field values on Generation_Range_Int64Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_Int64Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_Int64Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_Int64RangeMultiError, or nil if none found.
func (m *Generation_Range_Int64Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_Int64Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_Int64RangeMultiError(errors)
	}

	return nil
}

// Generation_Range_Int64RangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_Int64Range.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_Int64RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_Int64RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_Int64RangeMultiError) AllErrors() []error { return m }

// Generation_Range_Int64RangeValidationError is the validation error returned
// by Generation_Range_Int64Range.Validate if the designated constraints
// aren't met.
type Generation_Range_Int64RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_Int64RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_Int64RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_Int64RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_Int64RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_Int64RangeValidationError) ErrorName() string {
	return "Generation_Range_Int64RangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_Int64RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_Int64Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_Int64RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_Int64RangeValidationError{}

// Validate checks the field values on Generation_Range_UInt32Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_UInt32Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_UInt32Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_UInt32RangeMultiError, or nil if none found.
func (m *Generation_Range_UInt32Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_UInt32Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_UInt32RangeMultiError(errors)
	}

	return nil
}

// Generation_Range_UInt32RangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_UInt32Range.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_UInt32RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_UInt32RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_UInt32RangeMultiError) AllErrors() []error { return m }

// Generation_Range_UInt32RangeValidationError is the validation error returned
// by Generation_Range_UInt32Range.Validate if the designated constraints
// aren't met.
type Generation_Range_UInt32RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_UInt32RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_UInt32RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_UInt32RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_UInt32RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_UInt32RangeValidationError) ErrorName() string {
	return "Generation_Range_UInt32RangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_UInt32RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_UInt32Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_UInt32RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_UInt32RangeValidationError{}

// Validate checks the field values on Generation_Range_UInt64Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_UInt64Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_UInt64Range with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Range_UInt64RangeMultiError, or nil if none found.
func (m *Generation_Range_UInt64Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_UInt64Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_UInt64RangeMultiError(errors)
	}

	return nil
}

// Generation_Range_UInt64RangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_UInt64Range.ValidateAll() if
// the designated constraints aren't met.
type Generation_Range_UInt64RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_UInt64RangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_UInt64RangeMultiError) AllErrors() []error { return m }

// Generation_Range_UInt64RangeValidationError is the validation error returned
// by Generation_Range_UInt64Range.Validate if the designated constraints
// aren't met.
type Generation_Range_UInt64RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_UInt64RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_UInt64RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_UInt64RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_UInt64RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_UInt64RangeValidationError) ErrorName() string {
	return "Generation_Range_UInt64RangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_UInt64RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_UInt64Range.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_UInt64RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_UInt64RangeValidationError{}

// Validate checks the field values on Generation_Range_DecimalRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_DecimalRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_DecimalRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Generation_Range_DecimalRangeMultiError, or nil if none found.
func (m *Generation_Range_DecimalRange) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DecimalRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *Generation_Range_DecimalRange_Default_:
		if v == nil {
			err := Generation_Range_DecimalRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDefault()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Default",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Default",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DecimalRangeValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DecimalRange_Float:
		if v == nil {
			err := Generation_Range_DecimalRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetFloat()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Float",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Float",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFloat()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DecimalRangeValidationError{
					field:  "Float",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DecimalRange_Double:
		if v == nil {
			err := Generation_Range_DecimalRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDouble()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Double",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "Double",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDouble()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DecimalRangeValidationError{
					field:  "Double",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DecimalRange_String_:
		if v == nil {
			err := Generation_Range_DecimalRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetString_()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "String_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DecimalRangeValidationError{
						field:  "String_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetString_()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DecimalRangeValidationError{
					field:  "String_",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := Generation_Range_DecimalRangeValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Generation_Range_DecimalRangeMultiError(errors)
	}

	return nil
}

// Generation_Range_DecimalRangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_DecimalRange.ValidateAll()
// if the designated constraints aren't met.
type Generation_Range_DecimalRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DecimalRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DecimalRangeMultiError) AllErrors() []error { return m }

// Generation_Range_DecimalRangeValidationError is the validation error
// returned by Generation_Range_DecimalRange.Validate if the designated
// constraints aren't met.
type Generation_Range_DecimalRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DecimalRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DecimalRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DecimalRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DecimalRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DecimalRangeValidationError) ErrorName() string {
	return "Generation_Range_DecimalRangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DecimalRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DecimalRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DecimalRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DecimalRangeValidationError{}

// Validate checks the field values on Generation_Range_DateTimeRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_DateTimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_DateTimeRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Generation_Range_DateTimeRangeMultiError, or nil if none found.
func (m *Generation_Range_DateTimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DateTimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofTypePresent := false
	switch v := m.Type.(type) {
	case *Generation_Range_DateTimeRange_Default_:
		if v == nil {
			err := Generation_Range_DateTimeRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetDefault()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "Default",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "Default",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DateTimeRangeValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DateTimeRange_String_:
		if v == nil {
			err := Generation_Range_DateTimeRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetString_()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "String_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "String_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetString_()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DateTimeRangeValidationError{
					field:  "String_",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DateTimeRange_TimestampPb_:
		if v == nil {
			err := Generation_Range_DateTimeRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTimestampPb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "TimestampPb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "TimestampPb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimestampPb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DateTimeRangeValidationError{
					field:  "TimestampPb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Generation_Range_DateTimeRange_Timestamp_:
		if v == nil {
			err := Generation_Range_DateTimeRangeValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTypePresent = true

		if all {
			switch v := interface{}(m.GetTimestamp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "Timestamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Range_DateTimeRangeValidationError{
						field:  "Timestamp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Range_DateTimeRangeValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTypePresent {
		err := Generation_Range_DateTimeRangeValidationError{
			field:  "Type",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Generation_Range_DateTimeRangeMultiError(errors)
	}

	return nil
}

// Generation_Range_DateTimeRangeMultiError is an error wrapping multiple
// validation errors returned by Generation_Range_DateTimeRange.ValidateAll()
// if the designated constraints aren't met.
type Generation_Range_DateTimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DateTimeRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DateTimeRangeMultiError) AllErrors() []error { return m }

// Generation_Range_DateTimeRangeValidationError is the validation error
// returned by Generation_Range_DateTimeRange.Validate if the designated
// constraints aren't met.
type Generation_Range_DateTimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DateTimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DateTimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DateTimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DateTimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DateTimeRangeValidationError) ErrorName() string {
	return "Generation_Range_DateTimeRangeValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DateTimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DateTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DateTimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DateTimeRangeValidationError{}

// Validate checks the field values on Generation_Range_DecimalRange_Default
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Generation_Range_DecimalRange_Default) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Range_DecimalRange_Default
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Generation_Range_DecimalRange_DefaultMultiError, or nil if none found.
func (m *Generation_Range_DecimalRange_Default) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DecimalRange_Default) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DecimalRange_DefaultValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DecimalRange_DefaultValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DecimalRange_DefaultValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DecimalRange_DefaultValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DecimalRange_DefaultValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DecimalRange_DefaultValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Generation_Range_DecimalRange_DefaultMultiError(errors)
	}

	return nil
}

// Generation_Range_DecimalRange_DefaultMultiError is an error wrapping
// multiple validation errors returned by
// Generation_Range_DecimalRange_Default.ValidateAll() if the designated
// constraints aren't met.
type Generation_Range_DecimalRange_DefaultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DecimalRange_DefaultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DecimalRange_DefaultMultiError) AllErrors() []error { return m }

// Generation_Range_DecimalRange_DefaultValidationError is the validation error
// returned by Generation_Range_DecimalRange_Default.Validate if the
// designated constraints aren't met.
type Generation_Range_DecimalRange_DefaultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DecimalRange_DefaultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DecimalRange_DefaultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DecimalRange_DefaultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DecimalRange_DefaultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DecimalRange_DefaultValidationError) ErrorName() string {
	return "Generation_Range_DecimalRange_DefaultValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DecimalRange_DefaultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DecimalRange_Default.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DecimalRange_DefaultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DecimalRange_DefaultValidationError{}

// Validate checks the field values on Generation_Range_DateTimeRange_Default
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Generation_Range_DateTimeRange_Default) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Generation_Range_DateTimeRange_Default with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Generation_Range_DateTimeRange_DefaultMultiError, or nil if none found.
func (m *Generation_Range_DateTimeRange_Default) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DateTimeRange_Default) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_DefaultValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_DefaultValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DateTimeRange_DefaultValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_DefaultValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_DefaultValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DateTimeRange_DefaultValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Generation_Range_DateTimeRange_DefaultMultiError(errors)
	}

	return nil
}

// Generation_Range_DateTimeRange_DefaultMultiError is an error wrapping
// multiple validation errors returned by
// Generation_Range_DateTimeRange_Default.ValidateAll() if the designated
// constraints aren't met.
type Generation_Range_DateTimeRange_DefaultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DateTimeRange_DefaultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DateTimeRange_DefaultMultiError) AllErrors() []error { return m }

// Generation_Range_DateTimeRange_DefaultValidationError is the validation
// error returned by Generation_Range_DateTimeRange_Default.Validate if the
// designated constraints aren't met.
type Generation_Range_DateTimeRange_DefaultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DateTimeRange_DefaultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DateTimeRange_DefaultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DateTimeRange_DefaultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DateTimeRange_DefaultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DateTimeRange_DefaultValidationError) ErrorName() string {
	return "Generation_Range_DateTimeRange_DefaultValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DateTimeRange_DefaultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DateTimeRange_Default.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DateTimeRange_DefaultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DateTimeRange_DefaultValidationError{}

// Validate checks the field values on
// Generation_Range_DateTimeRange_TimestampPb with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Generation_Range_DateTimeRange_TimestampPb) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Generation_Range_DateTimeRange_TimestampPb with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Generation_Range_DateTimeRange_TimestampPbMultiError, or nil if none found.
func (m *Generation_Range_DateTimeRange_TimestampPb) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DateTimeRange_TimestampPb) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_TimestampPbValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_TimestampPbValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DateTimeRange_TimestampPbValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_TimestampPbValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Range_DateTimeRange_TimestampPbValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Range_DateTimeRange_TimestampPbValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Generation_Range_DateTimeRange_TimestampPbMultiError(errors)
	}

	return nil
}

// Generation_Range_DateTimeRange_TimestampPbMultiError is an error wrapping
// multiple validation errors returned by
// Generation_Range_DateTimeRange_TimestampPb.ValidateAll() if the designated
// constraints aren't met.
type Generation_Range_DateTimeRange_TimestampPbMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DateTimeRange_TimestampPbMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DateTimeRange_TimestampPbMultiError) AllErrors() []error { return m }

// Generation_Range_DateTimeRange_TimestampPbValidationError is the validation
// error returned by Generation_Range_DateTimeRange_TimestampPb.Validate if
// the designated constraints aren't met.
type Generation_Range_DateTimeRange_TimestampPbValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) ErrorName() string {
	return "Generation_Range_DateTimeRange_TimestampPbValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DateTimeRange_TimestampPbValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DateTimeRange_TimestampPb.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DateTimeRange_TimestampPbValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DateTimeRange_TimestampPbValidationError{}

// Validate checks the field values on Generation_Range_DateTimeRange_Timestamp
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Generation_Range_DateTimeRange_Timestamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Generation_Range_DateTimeRange_Timestamp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Generation_Range_DateTimeRange_TimestampMultiError, or nil if none found.
func (m *Generation_Range_DateTimeRange_Timestamp) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Range_DateTimeRange_Timestamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Generation_Range_DateTimeRange_TimestampMultiError(errors)
	}

	return nil
}

// Generation_Range_DateTimeRange_TimestampMultiError is an error wrapping
// multiple validation errors returned by
// Generation_Range_DateTimeRange_Timestamp.ValidateAll() if the designated
// constraints aren't met.
type Generation_Range_DateTimeRange_TimestampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Range_DateTimeRange_TimestampMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Range_DateTimeRange_TimestampMultiError) AllErrors() []error { return m }

// Generation_Range_DateTimeRange_TimestampValidationError is the validation
// error returned by Generation_Range_DateTimeRange_Timestamp.Validate if the
// designated constraints aren't met.
type Generation_Range_DateTimeRange_TimestampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Range_DateTimeRange_TimestampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Range_DateTimeRange_TimestampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Range_DateTimeRange_TimestampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Range_DateTimeRange_TimestampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Range_DateTimeRange_TimestampValidationError) ErrorName() string {
	return "Generation_Range_DateTimeRange_TimestampValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Range_DateTimeRange_TimestampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Range_DateTimeRange_Timestamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Range_DateTimeRange_TimestampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Range_DateTimeRange_TimestampValidationError{}

// Validate checks the field values on Generation_Rules_FloatRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_FloatRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_FloatRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_FloatRuleMultiError, or nil if none found.
func (m *Generation_Rules_FloatRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_FloatRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_FloatRuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_FloatRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_FloatRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_FloatRuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_FloatRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_FloatRuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_FloatRule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_FloatRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_FloatRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_FloatRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_FloatRuleValidationError is the validation error returned
// by Generation_Rules_FloatRule.Validate if the designated constraints aren't met.
type Generation_Rules_FloatRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_FloatRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_FloatRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_FloatRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_FloatRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_FloatRuleValidationError) ErrorName() string {
	return "Generation_Rules_FloatRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_FloatRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_FloatRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_FloatRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_FloatRuleValidationError{}

// Validate checks the field values on Generation_Rules_DoubleRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_DoubleRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_DoubleRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_DoubleRuleMultiError, or nil if none found.
func (m *Generation_Rules_DoubleRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_DoubleRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_DoubleRuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_DoubleRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_DoubleRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_DoubleRuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_DoubleRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_DoubleRuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_DoubleRule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_DoubleRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_DoubleRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_DoubleRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_DoubleRuleValidationError is the validation error returned
// by Generation_Rules_DoubleRule.Validate if the designated constraints
// aren't met.
type Generation_Rules_DoubleRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_DoubleRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_DoubleRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_DoubleRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_DoubleRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_DoubleRuleValidationError) ErrorName() string {
	return "Generation_Rules_DoubleRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_DoubleRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_DoubleRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_DoubleRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_DoubleRuleValidationError{}

// Validate checks the field values on Generation_Rules_Int32Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_Int32Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_Int32Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_Int32RuleMultiError, or nil if none found.
func (m *Generation_Rules_Int32Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_Int32Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_Int32RuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_Int32RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_Int32RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_Int32RuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_Int32RuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_Int32RuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_Int32Rule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_Int32RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_Int32RuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_Int32RuleMultiError) AllErrors() []error { return m }

// Generation_Rules_Int32RuleValidationError is the validation error returned
// by Generation_Rules_Int32Rule.Validate if the designated constraints aren't met.
type Generation_Rules_Int32RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_Int32RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_Int32RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_Int32RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_Int32RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_Int32RuleValidationError) ErrorName() string {
	return "Generation_Rules_Int32RuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_Int32RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_Int32Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_Int32RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_Int32RuleValidationError{}

// Validate checks the field values on Generation_Rules_Int64Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_Int64Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_Int64Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_Int64RuleMultiError, or nil if none found.
func (m *Generation_Rules_Int64Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_Int64Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_Int64RuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_Int64RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_Int64RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_Int64RuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_Int64RuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_Int64RuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_Int64Rule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_Int64RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_Int64RuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_Int64RuleMultiError) AllErrors() []error { return m }

// Generation_Rules_Int64RuleValidationError is the validation error returned
// by Generation_Rules_Int64Rule.Validate if the designated constraints aren't met.
type Generation_Rules_Int64RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_Int64RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_Int64RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_Int64RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_Int64RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_Int64RuleValidationError) ErrorName() string {
	return "Generation_Rules_Int64RuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_Int64RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_Int64Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_Int64RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_Int64RuleValidationError{}

// Validate checks the field values on Generation_Rules_UInt32Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_UInt32Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_UInt32Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_UInt32RuleMultiError, or nil if none found.
func (m *Generation_Rules_UInt32Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_UInt32Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_UInt32RuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_UInt32RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_UInt32RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_UInt32RuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_UInt32RuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_UInt32RuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_UInt32Rule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_UInt32RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_UInt32RuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_UInt32RuleMultiError) AllErrors() []error { return m }

// Generation_Rules_UInt32RuleValidationError is the validation error returned
// by Generation_Rules_UInt32Rule.Validate if the designated constraints
// aren't met.
type Generation_Rules_UInt32RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_UInt32RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_UInt32RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_UInt32RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_UInt32RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_UInt32RuleValidationError) ErrorName() string {
	return "Generation_Rules_UInt32RuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_UInt32RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_UInt32Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_UInt32RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_UInt32RuleValidationError{}

// Validate checks the field values on Generation_Rules_UInt64Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_UInt64Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_UInt64Rule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_UInt64RuleMultiError, or nil if none found.
func (m *Generation_Rules_UInt64Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_UInt64Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_UInt64RuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_UInt64RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_UInt64RuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_UInt64RuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_UInt64RuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_UInt64RuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_UInt64Rule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_UInt64RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_UInt64RuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_UInt64RuleMultiError) AllErrors() []error { return m }

// Generation_Rules_UInt64RuleValidationError is the validation error returned
// by Generation_Rules_UInt64Rule.Validate if the designated constraints
// aren't met.
type Generation_Rules_UInt64RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_UInt64RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_UInt64RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_UInt64RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_UInt64RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_UInt64RuleValidationError) ErrorName() string {
	return "Generation_Rules_UInt64RuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_UInt64RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_UInt64Rule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_UInt64RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_UInt64RuleValidationError{}

// Validate checks the field values on Generation_Rules_BoolRule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_BoolRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_BoolRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_BoolRuleMultiError, or nil if none found.
func (m *Generation_Rules_BoolRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_BoolRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_BoolRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_BoolRuleMultiError is an error wrapping multiple validation
// errors returned by Generation_Rules_BoolRule.ValidateAll() if the
// designated constraints aren't met.
type Generation_Rules_BoolRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_BoolRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_BoolRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_BoolRuleValidationError is the validation error returned by
// Generation_Rules_BoolRule.Validate if the designated constraints aren't met.
type Generation_Rules_BoolRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_BoolRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_BoolRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_BoolRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_BoolRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_BoolRuleValidationError) ErrorName() string {
	return "Generation_Rules_BoolRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_BoolRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_BoolRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_BoolRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_BoolRuleValidationError{}

// Validate checks the field values on Generation_Rules_StringRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_StringRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_StringRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_StringRuleMultiError, or nil if none found.
func (m *Generation_Rules_StringRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_StringRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetLenRange() == nil {
		err := Generation_Rules_StringRuleValidationError{
			field:  "LenRange",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLenRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_StringRuleValidationError{
					field:  "LenRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_StringRuleValidationError{
					field:  "LenRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLenRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_StringRuleValidationError{
				field:  "LenRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Alphabet != nil {

		if all {
			switch v := interface{}(m.GetAlphabet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Rules_StringRuleValidationError{
						field:  "Alphabet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Rules_StringRuleValidationError{
						field:  "Alphabet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAlphabet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Rules_StringRuleValidationError{
					field:  "Alphabet",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Constant != nil {
		// no validation rules for Constant
	}

	if len(errors) > 0 {
		return Generation_Rules_StringRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_StringRuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_StringRule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_StringRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_StringRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_StringRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_StringRuleValidationError is the validation error returned
// by Generation_Rules_StringRule.Validate if the designated constraints
// aren't met.
type Generation_Rules_StringRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_StringRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_StringRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_StringRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_StringRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_StringRuleValidationError) ErrorName() string {
	return "Generation_Rules_StringRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_StringRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_StringRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_StringRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_StringRuleValidationError{}

// Validate checks the field values on Generation_Rules_DateTimeRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_DateTimeRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_DateTimeRule with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Generation_Rules_DateTimeRuleMultiError, or nil if none found.
func (m *Generation_Rules_DateTimeRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_DateTimeRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_DateTimeRuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_DateTimeRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_DateTimeRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_DateTimeRuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {

		if all {
			switch v := interface{}(m.GetConstant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Rules_DateTimeRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Rules_DateTimeRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConstant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Rules_DateTimeRuleValidationError{
					field:  "Constant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Generation_Rules_DateTimeRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_DateTimeRuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_DateTimeRule.ValidateAll()
// if the designated constraints aren't met.
type Generation_Rules_DateTimeRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_DateTimeRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_DateTimeRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_DateTimeRuleValidationError is the validation error
// returned by Generation_Rules_DateTimeRule.Validate if the designated
// constraints aren't met.
type Generation_Rules_DateTimeRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_DateTimeRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_DateTimeRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_DateTimeRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_DateTimeRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_DateTimeRuleValidationError) ErrorName() string {
	return "Generation_Rules_DateTimeRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_DateTimeRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_DateTimeRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_DateTimeRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_DateTimeRuleValidationError{}

// Validate checks the field values on Generation_Rules_UuidRule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_UuidRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_UuidRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_UuidRuleMultiError, or nil if none found.
func (m *Generation_Rules_UuidRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_UuidRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Constant != nil {

		if all {
			switch v := interface{}(m.GetConstant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Rules_UuidRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Rules_UuidRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConstant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Rules_UuidRuleValidationError{
					field:  "Constant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Generation_Rules_UuidRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_UuidRuleMultiError is an error wrapping multiple validation
// errors returned by Generation_Rules_UuidRule.ValidateAll() if the
// designated constraints aren't met.
type Generation_Rules_UuidRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_UuidRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_UuidRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_UuidRuleValidationError is the validation error returned by
// Generation_Rules_UuidRule.Validate if the designated constraints aren't met.
type Generation_Rules_UuidRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_UuidRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_UuidRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_UuidRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_UuidRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_UuidRuleValidationError) ErrorName() string {
	return "Generation_Rules_UuidRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_UuidRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_UuidRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_UuidRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_UuidRuleValidationError{}

// Validate checks the field values on Generation_Rules_DecimalRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Generation_Rules_DecimalRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Generation_Rules_DecimalRule with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Generation_Rules_DecimalRuleMultiError, or nil if none found.
func (m *Generation_Rules_DecimalRule) ValidateAll() error {
	return m.validate(true)
}

func (m *Generation_Rules_DecimalRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRange() == nil {
		err := Generation_Rules_DecimalRuleValidationError{
			field:  "Range",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Generation_Rules_DecimalRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Generation_Rules_DecimalRuleValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Generation_Rules_DecimalRuleValidationError{
				field:  "Range",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Constant != nil {

		if all {
			switch v := interface{}(m.GetConstant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Generation_Rules_DecimalRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Generation_Rules_DecimalRuleValidationError{
						field:  "Constant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConstant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Generation_Rules_DecimalRuleValidationError{
					field:  "Constant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Generation_Rules_DecimalRuleMultiError(errors)
	}

	return nil
}

// Generation_Rules_DecimalRuleMultiError is an error wrapping multiple
// validation errors returned by Generation_Rules_DecimalRule.ValidateAll() if
// the designated constraints aren't met.
type Generation_Rules_DecimalRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Generation_Rules_DecimalRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Generation_Rules_DecimalRuleMultiError) AllErrors() []error { return m }

// Generation_Rules_DecimalRuleValidationError is the validation error returned
// by Generation_Rules_DecimalRule.Validate if the designated constraints
// aren't met.
type Generation_Rules_DecimalRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Generation_Rules_DecimalRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Generation_Rules_DecimalRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Generation_Rules_DecimalRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Generation_Rules_DecimalRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Generation_Rules_DecimalRuleValidationError) ErrorName() string {
	return "Generation_Rules_DecimalRuleValidationError"
}

// Error satisfies the builtin error interface
func (e Generation_Rules_DecimalRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneration_Rules_DecimalRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Generation_Rules_DecimalRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Generation_Rules_DecimalRuleValidationError{}
